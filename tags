!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
AddToQueue	queue.c	/^void AddToQueue(Queue *queue,char *key, int loc){$/;"	f
AddToTable	hashtable.c	/^void AddToTable(HashTable *table, char * key){$/;"	f
CheckTable	hashtable.c	/^bool CheckTable(HashTable *table, char * key){$/;"	f
ClearHeap	heap.c	/^void ClearHeap(Heap *h){$/;"	f
ClearLevel	level.c	/^void ClearLevel(Level *l){$/;"	f
ClearLog	value-log.c	/^void ClearLog(ValueLog *log){$/;"	f
ClearQueue	queue.c	/^void ClearQueue(Queue *queue){$/;"	f
ClearTable	hashtable.c	/^void ClearTable(HashTable *table){$/;"	f
CreateHashTable	hashtable.c	/^HashTable *CreateHashTable(int size){$/;"	f
CreateHeap	heap.c	/^Heap *CreateHeap(int size){$/;"	f
CreateLSM	lsm-tree.c	/^LSMtree *CreateLSM(int buffersize, int sizeratio, double fpr){$/;"	f
CreateLevel	level.c	/^Level *CreateLevel(int size, double fpr){$/;"	f
CreateLog	value-log.c	/^ValueLog *CreateLog(int head, int tail){$/;"	f
CreateQueue	queue.c	/^Queue *CreateQueue(int size){$/;"	f
Delete	lsm-tree.c	/^void Delete(LSMtree *lsm, char * key){$/;"	f
Delete_flag	compaction.c	/^int Delete_flag(Node * sort, int size){$/;"	f
Element	global.h	/^typedef struct Element{$/;"	s
Element	global.h	/^}Element;$/;"	t	typeref:struct:Element
FAST_MAX_PAGE	global.h	33;"	d
FAST_OFFSET	global.h	41;"	d
FILE_NAME	global.h	48;"	d
FastMem	global.h	/^typedef struct FastMem{$/;"	s
FastMem	global.h	/^}FastMem;$/;"	t	typeref:struct:FastMem
GC	value-log.c	/^void GC(LSMtree *lsm,ValueLog *log){$/;"	f
GC_function	test.c	/^void *GC_function(void *argument){$/;"	f
Get	lsm-tree.c	/^int Get(LSMtree *lsm, char * key, ValueLog *log){	$/;"	f
GetKeyPos	heap.c	/^int GetKeyPos(LSMtree *lsm, char * key){$/;"	f
GetToQueue	queue.c	/^Element * GetToQueue(Queue *queue){$/;"	f
Get_array	lsm-tree.c	/^SaveArray * Get_array(LSMtree *lsm, char * key){$/;"	f
Get_loc	lsm-tree.c	/^Node * Get_loc(LSMtree *lsm, char * key){$/;"	f
HashTable	global.h	/^typedef struct HashTable{$/;"	s
HashTable	global.h	/^} HashTable;$/;"	t	typeref:struct:HashTable
Heap	global.h	/^typedef struct Heap{$/;"	s
Heap	global.h	/^} Heap;$/;"	t	typeref:struct:Heap
HeapifyBottomTop	heap.c	/^void HeapifyBottomTop(Heap *h, int index){$/;"	f
HeapifyTopBottom	heap.c	/^void HeapifyTopBottom(Heap *h, int parent){$/;"	f
INDEX	global.h	40;"	d
INT_MAX	compaction.c	2;"	d	file:
INT_MAX	lsm-tree.c	3;"	d	file:
INT_MAX	test.c	4;"	d	file:
InsertKey	heap.c	/^void InsertKey(LSMtree *lsm, char * key, int value, bool flag,int locking){$/;"	f
InsertRun	level.c	/^void InsertRun(LSMtree *lsm, Level *level, int count, int size, char * start, char * end){$/;"	f
L0	global.h	/^	LevelNode *L0;$/;"	m	struct:LSMtree
LOC_FAST	global.h	47;"	d
LOC_SLOW	value-log.c	3;"	d	file:
LSMtree	global.h	/^typedef struct LSMtree{$/;"	s
LSMtree	global.h	/^} LSMtree;$/;"	t	typeref:struct:LSMtree
Level	global.h	/^typedef struct Level{$/;"	s
Level	global.h	/^} Level;$/;"	t	typeref:struct:Level
LevelNode	global.h	/^typedef struct LevelNode{$/;"	s
LevelNode	global.h	/^} LevelNode;$/;"	t	typeref:struct:LevelNode
MAPPING_LOG_SIZE	global.h	34;"	d
MAX_LOG_MAPPING	global.h	38;"	d
MAX_LOG_SIZE	global.h	31;"	d
MAX_PAGE	global.h	30;"	d
MAX_THREAD	global.h	46;"	d
MAX_VALUE_SIZE	global.h	28;"	d
Merge	compaction.c	/^void Merge(LSMtree * lsm,LevelNode *Current, int origin, int levelsize,$/;"	f
Merge_Arg	global.h	/^typedef struct Merge_Arg{$/;"	s
Merge_Arg	global.h	/^}Merge_Arg;$/;"	t	typeref:struct:Merge_Arg
Merge_routin	lsm-tree.c	/^void * Merge_routin(void * arg){$/;"	f
Node	global.h	/^typedef struct Node{$/;"	s
Node	global.h	/^} Node;$/;"	t	typeref:struct:Node
OFFSET	global.h	43;"	d
PopMin	heap.c	/^Node PopMin(LSMtree *lsm){$/;"	f
PopRun	level.c	/^Run PopRun(LSMtree *lsm,Level *level){$/;"	f
PrintNode	heap.c	/^void PrintNode(LSMtree * lsm, ValueLog *log){$/;"	f
PrintStats	lsm-tree.c	/^void PrintStats(LSMtree *lsm, ValueLog *log){$/;"	f
Put	lsm-tree.c	/^void Put(LSMtree *lsm, char * key, int value, bool flag,ValueLog *log){$/;"	f
Queue	global.h	/^typedef struct Queue{$/;"	s
Queue	global.h	/^} Queue;$/;"	t	typeref:struct:Queue
REPEAT	test.c	3;"	d	file:
Range	lsm-tree.c	/^void Range(LSMtree *lsm, char * start, char * end,ValueLog *log){$/;"	f
Run	global.h	/^typedef struct Run{$/;"	s
Run	global.h	/^} Run;$/;"	t	typeref:struct:Run
SIZE	test.c	5;"	d	file:
SLOW_MAX_PAGE	global.h	36;"	d
SLOW_OFFSET	global.h	42;"	d
STRING_SIZE	global.h	27;"	d
SaveArray	global.h	/^}SaveArray;$/;"	t	typeref:struct:Save_Array
SaveLog	global.h	/^} SaveLog;$/;"	t	typeref:struct:Save_Log
Save_Array	global.h	/^typedef struct Save_Array{$/;"	s
Save_Log	global.h	/^typedef struct Save_Log{$/;"	s
SlowMem	global.h	/^typedef struct SlowMem{$/;"	s
SlowMem	global.h	/^}SlowMem;$/;"	t	typeref:struct:SlowMem
SlowPut	value-log.c	/^void SlowPut(ValueLog *log, int *loc, const char *key, uint64_t key_len, uint64_t value){$/;"	f
T	global.h	/^	int T;$/;"	m	struct:LSMtree
THREAD_NUM	test.c	6;"	d	file:
TO_SLOW	value-log.c	4;"	d	file:
TakeArg	global.h	/^typedef struct TakeArg{$/;"	s
TakeArg	global.h	/^}TakeArg;$/;"	t	typeref:struct:TakeArg
Test_Arg	test.c	/^}Test_Arg;$/;"	t	typeref:struct:test_art	file:
UTILIZATION	global.h	35;"	d
ValueGet	value-log.c	/^uint64_t ValueGet(ValueLog *log,int loc){$/;"	f
ValueLog	global.h	/^typedef struct ValueLog{$/;"	s
ValueLog	global.h	/^} ValueLog;$/;"	t	typeref:struct:ValueLog
ValuePut	value-log.c	/^int ValuePut(LSMtree *lsm,ValueLog *log, int *loc, const char * key, uint64_t key_len, uint64_t value,int flag){$/;"	f
_GNU_SOURCE	global.h	1;"	d
array	global.h	/^	Element **array;$/;"	m	struct:Queue
array	global.h	/^	Node * array;$/;"	m	struct:Merge_Arg
array	global.h	/^	Node * array;$/;"	m	struct:Save_Array
array	global.h	/^	Node *array;$/;"	m	struct:Heap
array	global.h	/^	Run *array;$/;"	m	struct:Level
array	global.h	/^	char **array;$/;"	m	struct:HashTable
buffer	global.h	/^	Heap *buffer;$/;"	m	struct:LSMtree
buffer_lock	global.h	/^	pthread_rwlock_t buffer_lock; \/\/buffer에 거는 lock$/;"	m	struct:LSMtree
cmpfunc	compaction.c	/^int cmpfunc(const void *a, const void *b){$/;"	f
cond	global.h	/^	pthread_cond_t cond;$/;"	m	struct:ValueLog
count	global.h	/^	int count;$/;"	m	struct:HashTable
count	global.h	/^	int count;$/;"	m	struct:Heap
count	global.h	/^	int count;$/;"	m	struct:Level
count	global.h	/^	int count;$/;"	m	struct:Run
dead	lsm-tree.c	/^int dead = 0;$/;"	v
end	global.h	/^	char end[STRING_SIZE];$/;"	m	struct:Run
fast	global.h	/^	FastMem *fast;$/;"	m	struct:ValueLog
fast_lock	global.h	/^	pthread_mutex_t fast_lock;$/;"	m	struct:ValueLog
filename	global.h	/^	char filename[FILE_NAME];$/;"	m	struct:Save_Array
finish	global.h	/^	bool finish;$/;"	m	struct:TakeArg
flag	global.h	/^	bool flag;$/;"	m	struct:Node
fp	global.h	/^	SaveLog * fp;$/;"	m	struct:FastMem
fp	global.h	/^	SaveLog * fp;$/;"	m	struct:SlowMem
fpr1	global.h	/^	double fpr1;$/;"	m	struct:LSMtree
front	global.h	/^	int front;$/;"	m	struct:Queue
get_log	lsm-tree.c	/^void *get_log(void *argument){$/;"	f
global_lock	global.h	/^	pthread_rwlock_t global_lock; \/\/각 level에 input output을 진행할 때 거는 lock$/;"	m	struct:Level
head	global.h	/^	int head;$/;"	m	struct:FastMem
head	global.h	/^	int head;$/;"	m	struct:SlowMem
index	global.h	/^	int index;$/;"	m	struct:Save_Array
is_empty	queue.c	/^bool is_empty(Queue *queue){$/;"	f
is_full	queue.c	/^bool is_full(Queue *queue){$/;"	f
key	global.h	/^	char key[STRING_SIZE];$/;"	m	struct:Element
key	global.h	/^	char key[STRING_SIZE];$/;"	m	struct:Node
key	global.h	/^	char key[STRING_SIZE];$/;"	m	struct:Save_Log
key_len	global.h	/^	int key_len;$/;"	m	struct:Save_Log
level	global.h	/^	Level *level;$/;"	m	struct:LevelNode
level	global.h	/^	Level *level;$/;"	m	struct:Save_Array
level_lock	global.h	/^	pthread_rwlock_t level_lock; \/\/각 level에 input output을 진행할 때 거는 lock$/;"	m	struct:Level
loc	global.h	/^	int loc;$/;"	m	struct:Element
log	global.h	/^	ValueLog *log;$/;"	m	struct:TakeArg
log	test.c	/^	ValueLog *log;$/;"	m	struct:test_art	file:
lsm	global.h	/^	LSMtree *lsm;$/;"	m	struct:Merge_Arg
lsm	test.c	/^	LSMtree *lsm;$/;"	m	struct:test_art	file:
main	test.c	/^int main(int argc ,char *argv[]){$/;"	f
make_level_lock	global.h	/^	pthread_mutex_t make_level_lock; \/\/level를 만들떄 임시로 거는 lock$/;"	m	struct:LSMtree
merge_lock	global.h	/^	pthread_rwlock_t merge_lock; \/\/GC가 일어날때 lsm tree의 구조 변화를 막기 위해 merge 불가 상태로 만드는 lock$/;"	m	struct:LSMtree
next	global.h	/^	struct LevelNode *next;$/;"	m	struct:LevelNode	typeref:struct:LevelNode::LevelNode
number	global.h	/^	int number;$/;"	m	struct:LevelNode
number	global.h	/^	int number;$/;"	m	struct:Save_Array
q	global.h	/^	Queue *q;$/;"	m	struct:TakeArg
rear	global.h	/^	int rear;$/;"	m	struct:Queue
size	global.h	/^	int size;$/;"	m	struct:Heap
size	global.h	/^	int size;$/;"	m	struct:Level
size	global.h	/^	int size;$/;"	m	struct:Queue
size	global.h	/^	int size;$/;"	m	struct:Run
size	global.h	/^	int size;$/;"	m	struct:Save_Array
slow	global.h	/^	SlowMem *slow;$/;"	m	struct:ValueLog
slow_input	test.c	/^int slow_input = 0;$/;"	v
start	global.h	/^	char start[STRING_SIZE];$/;"	m	struct:Run
tail	global.h	/^	int tail;$/;"	m	struct:FastMem
targetfpr	global.h	/^	double targetfpr;$/;"	m	struct:Level
test_art	test.c	/^typedef struct test_art{$/;"	s	file:
thread_function	test.c	/^void *thread_function(void *argument){$/;"	f
utili	global.h	/^	int utili;$/;"	m	struct:FastMem
value	global.h	/^	int value;$/;"	m	struct:Node
value	global.h	/^	int value;$/;"	m	struct:Save_Log
